<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>setInterval vs requestAnimationFrame 비교</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      padding: 40px;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
    }

    h1 {
      margin-bottom: 10px;
      color: #fff;
    }

    .description {
      color: #888;
      margin-bottom: 30px;
    }

    .mode-selector {
      display: flex;
      gap: 0;
      margin-bottom: 20px;
      background: #0f0f23;
      border-radius: 12px;
      padding: 6px;
      width: fit-content;
    }

    .mode-btn {
      padding: 14px 32px;
      font-size: 14px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      background: transparent;
      color: #888;
      transition: all 0.2s;
    }

    .mode-btn:hover {
      color: #fff;
    }

    .mode-btn.active.interval {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
    }

    .mode-btn.active.raf {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      color: white;
    }

    .settings {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      align-items: center;
    }

    .setting-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .setting-group label {
      color: #888;
      font-size: 13px;
    }

    .setting-group select, .setting-group input {
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid #333;
      background: #16213e;
      color: #fff;
      font-size: 13px;
    }

    .controls {
      display: flex;
      gap: 15px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }

    button {
      padding: 12px 24px;
      font-size: 14px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      transition: transform 0.1s, box-shadow 0.1s;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    button:active {
      transform: translateY(0);
    }

    .btn-start {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-stop {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
    }

    .btn-reset {
      background: #333;
      color: white;
    }

    .current-mode {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-bottom: 20px;
      padding: 20px;
      background: #16213e;
      border-radius: 12px;
    }

    .current-mode h2 {
      font-size: 24px;
    }

    .current-mode.interval h2 {
      color: #f5576c;
    }

    .current-mode.raf h2 {
      color: #4facfe;
    }

    .badge {
      font-size: 11px;
      padding: 4px 10px;
      border-radius: 20px;
      font-weight: 600;
    }

    .badge.bad {
      background: rgba(245, 87, 108, 0.2);
      color: #f5576c;
    }

    .badge.good {
      background: rgba(79, 172, 254, 0.2);
      color: #4facfe;
    }

    .stats {
      display: flex;
      gap: 20px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }

    .stat-box {
      background: #16213e;
      padding: 20px 30px;
      border-radius: 12px;
      min-width: 130px;
      text-align: center;
    }

    .stat-box h3 {
      font-size: 11px;
      text-transform: uppercase;
      color: #888;
      margin-bottom: 8px;
    }

    .stat-box .value {
      font-size: 28px;
      font-weight: bold;
      color: #4facfe;
    }

    .stat-box .value.warning {
      color: #ffc107;
    }

    .stat-box .value.danger {
      color: #f5576c;
    }

    .animation-container {
      background: #0f0f23;
      border-radius: 12px;
      padding: 20px;
      position: relative;
      height: 400px;
      overflow: hidden;
    }

    .particle {
      position: absolute;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      pointer-events: none;
    }

    .particle.interval {
      background: radial-gradient(circle, #f5576c 0%, #f093fb 100%);
      box-shadow: 0 0 10px rgba(245, 87, 108, 0.5);
    }

    .particle.raf {
      background: radial-gradient(circle, #00f2fe 0%, #4facfe 100%);
      box-shadow: 0 0 10px rgba(79, 172, 254, 0.5);
    }

    .info {
      margin-top: 40px;
      padding: 20px;
      background: #16213e;
      border-radius: 12px;
      border-left: 4px solid #667eea;
    }

    .info h3 {
      margin-bottom: 15px;
      color: #fff;
    }

    .info p {
      color: #aaa;
      line-height: 1.7;
      margin-bottom: 10px;
    }

    .info code {
      background: rgba(255,255,255,0.1);
      padding: 2px 8px;
      border-radius: 4px;
      font-family: 'SF Mono', Monaco, monospace;
      color: #4facfe;
    }

    .warning-box {
      margin-top: 20px;
      padding: 15px;
      background: rgba(255, 193, 7, 0.1);
      border-left: 4px solid #ffc107;
      border-radius: 8px;
    }

    .warning-box p {
      color: #ffc107;
      margin: 0;
    }
  </style>
</head>
<body>
  <h1>setInterval vs requestAnimationFrame (Heavy)</h1>
  <p class="description">복잡한 계산이 포함된 파티클 애니메이션으로 두 방식의 성능 차이를 비교합니다.</p>

  <div class="mode-selector">
    <button class="mode-btn interval active" onclick="selectMode('interval')">setInterval (16ms)</button>
    <button class="mode-btn raf" onclick="selectMode('raf')">requestAnimationFrame</button>
  </div>

  <div class="settings">
    <div class="setting-group">
      <label>파티클 수:</label>
      <select id="particle-count" onchange="updateSettings()">
        <option value="100">100개</option>
        <option value="200">200개</option>
        <option value="300" selected>300개</option>
        <option value="500">500개</option>
        <option value="1000">1000개 (Heavy)</option>
      </select>
    </div>
    <div class="setting-group">
      <label>계산 복잡도:</label>
      <select id="complexity" onchange="updateSettings()">
        <option value="low">낮음</option>
        <option value="medium" selected>중간</option>
        <option value="high">높음</option>
        <option value="extreme">극한</option>
      </select>
    </div>
  </div>

  <div class="current-mode interval" id="current-mode">
    <h2 id="mode-title">setInterval (16ms)</h2>
    <span class="badge bad" id="mode-badge">비권장</span>
  </div>

  <div class="controls">
    <button class="btn-start" onclick="startAnimation()">▶ 애니메이션 시작</button>
    <button class="btn-stop" onclick="stopAnimation()">⏹ 정지</button>
    <button class="btn-reset" onclick="resetAnimation()">↺ 리셋</button>
  </div>

  <div class="stats">
    <div class="stat-box">
      <h3>FPS</h3>
      <div class="value" id="current-fps">--</div>
    </div>
    <div class="stat-box">
      <h3>프레임 드롭</h3>
      <div class="value" id="frame-drops">0</div>
    </div>
    <div class="stat-box">
      <h3>평균 프레임 시간</h3>
      <div class="value" id="avg-frame-time">--</div>
    </div>
    <div class="stat-box">
      <h3>최대 프레임 시간</h3>
      <div class="value" id="max-frame-time">--</div>
    </div>
  </div>

  <div class="animation-container" id="animation-container"></div>

  <div class="info">
    <h3>테스트 방법</h3>
    <p>1. DevTools → Performance 탭 → CPU throttling <strong>6x slowdown</strong> 설정</p>
    <p>2. <strong>setInterval</strong> 모드로 애니메이션 시작 → 녹화 3초</p>
    <p>3. <strong>requestAnimationFrame</strong> 모드로 전환 → 녹화 3초</p>
    <p>4. 두 결과의 FPS 그래프, 프레임 드롭, Main 스레드 패턴 비교</p>

    <div class="warning-box">
      <p>⚠️ CPU throttling을 켜면 차이가 명확해집니다. 파티클 수와 복잡도를 높이면 더 극적인 차이를 볼 수 있습니다.</p>
    </div>
  </div>

  <script>
    const container = document.getElementById('animation-container')
    let currentMode = 'interval'
    let isRunning = false
    let particles = []
    let settings = {
      count: 300,
      complexity: 'medium'
    }

    // 파티클 클래스
    class Particle {
      constructor(index) {
        this.index = index
        this.x = Math.random() * container.offsetWidth
        this.y = Math.random() * container.offsetHeight
        this.vx = (Math.random() - 0.5) * 4
        this.vy = (Math.random() - 0.5) * 4
        this.angle = Math.random() * Math.PI * 2
        this.angularVelocity = (Math.random() - 0.5) * 0.1
        this.size = 8 + Math.random() * 8
        this.hue = Math.random() * 60

        this.element = document.createElement('div')
        this.element.className = `particle ${currentMode}`
        this.element.style.width = this.size + 'px'
        this.element.style.height = this.size + 'px'
        container.appendChild(this.element)
      }

      update(time, allParticles) {
        // 기본 물리
        this.angle += this.angularVelocity
        this.x += this.vx + Math.sin(this.angle) * 2
        this.y += this.vy + Math.cos(this.angle) * 2

        // 벽 충돌
        if (this.x < 0 || this.x > container.offsetWidth - this.size) {
          this.vx *= -1
          this.x = Math.max(0, Math.min(this.x, container.offsetWidth - this.size))
        }
        if (this.y < 0 || this.y > container.offsetHeight - this.size) {
          this.vy *= -1
          this.y = Math.max(0, Math.min(this.y, container.offsetHeight - this.size))
        }

        // 복잡도에 따른 추가 계산
        if (settings.complexity === 'medium' || settings.complexity === 'high' || settings.complexity === 'extreme') {
          // 사인파 움직임 추가
          this.x += Math.sin(time * 0.001 + this.index * 0.1) * 0.5
          this.y += Math.cos(time * 0.001 + this.index * 0.1) * 0.5
        }

        if (settings.complexity === 'high' || settings.complexity === 'extreme') {
          // 다른 파티클과의 거리 계산 (N^2 복잡도)
          let nearbyCount = 0
          for (let i = 0; i < Math.min(50, allParticles.length); i++) {
            const other = allParticles[i]
            if (other === this) continue
            const dx = other.x - this.x
            const dy = other.y - this.y
            const dist = Math.sqrt(dx * dx + dy * dy)
            if (dist < 100) {
              nearbyCount++
              // 살짝 밀어내기
              this.vx -= dx * 0.0001
              this.vy -= dy * 0.0001
            }
          }
        }

        if (settings.complexity === 'extreme') {
          // 극한 복잡도: 더 많은 파티클과 거리 계산
          for (let i = 0; i < allParticles.length; i++) {
            const other = allParticles[i]
            if (other === this) continue
            const dx = other.x - this.x
            const dy = other.y - this.y
            const dist = Math.sqrt(dx * dx + dy * dy)
            if (dist < 50) {
              this.vx -= dx * 0.00005
              this.vy -= dy * 0.00005
            }
          }

          // 추가 삼각함수 계산
          for (let i = 0; i < 10; i++) {
            const dummy = Math.sin(time * 0.001 * i) * Math.cos(this.x * 0.01) * Math.tan(this.y * 0.01 + 0.1)
          }
        }

        // DOM 업데이트
        this.element.style.transform = `translate(${this.x}px, ${this.y}px)`
      }

      destroy() {
        this.element.remove()
      }
    }

    // 파티클 생성
    function createParticles() {
      particles.forEach(p => p.destroy())
      particles = []
      for (let i = 0; i < settings.count; i++) {
        particles.push(new Particle(i))
      }
    }

    function updateSettings() {
      settings.count = parseInt(document.getElementById('particle-count').value)
      settings.complexity = document.getElementById('complexity').value
      if (!isRunning) {
        createParticles()
      }
    }

    // 애니메이션 상태
    let intervalTimers = []
    let rafId = null
    let frameDrops = 0
    let frameTimes = []
    let lastFrameTime = 0

    // FPS 측정
    let fpsFrames = 0
    let fpsLastTime = performance.now()
    let fpsRafId = null

    function selectMode(mode) {
      if (isRunning) {
        stopAnimation()
      }
      resetAnimation()

      currentMode = mode
      createParticles()

      // UI 업데이트
      document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.classList.remove('active')
      })
      document.querySelector(`.mode-btn.${mode}`).classList.add('active')

      const modeEl = document.getElementById('current-mode')
      const titleEl = document.getElementById('mode-title')
      const badgeEl = document.getElementById('mode-badge')

      modeEl.className = `current-mode ${mode}`

      if (mode === 'interval') {
        titleEl.textContent = 'setInterval (16ms)'
        badgeEl.textContent = '비권장'
        badgeEl.className = 'badge bad'
      } else {
        titleEl.textContent = 'requestAnimationFrame'
        badgeEl.textContent = '권장'
        badgeEl.className = 'badge good'
      }
    }

    function measureFps() {
      fpsFrames++
      const now = performance.now()
      if (now - fpsLastTime >= 1000) {
        const fpsEl = document.getElementById('current-fps')
        fpsEl.textContent = fpsFrames
        fpsEl.className = 'value' + (fpsFrames < 30 ? ' danger' : fpsFrames < 50 ? ' warning' : '')
        fpsFrames = 0
        fpsLastTime = now
      }
      if (isRunning) {
        fpsRafId = requestAnimationFrame(measureFps)
      }
    }

    function updateStats(frameTime) {
      frameTimes.push(frameTime)
      if (frameTimes.length > 60) frameTimes.shift()

      if (frameTime > 25) {
        frameDrops++
        document.getElementById('frame-drops').textContent = frameDrops
      }

      const avg = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length
      const max = Math.max(...frameTimes)

      const avgEl = document.getElementById('avg-frame-time')
      avgEl.textContent = avg.toFixed(1) + 'ms'
      avgEl.className = 'value' + (avg > 33 ? ' danger' : avg > 20 ? ' warning' : '')

      const maxEl = document.getElementById('max-frame-time')
      maxEl.textContent = max.toFixed(1) + 'ms'
      maxEl.className = 'value' + (max > 50 ? ' danger' : max > 30 ? ' warning' : '')
    }

    function startAnimation() {
      if (isRunning) return
      isRunning = true
      createParticles()

      // FPS 측정 시작
      fpsFrames = 0
      fpsLastTime = performance.now()
      fpsRafId = requestAnimationFrame(measureFps)

      if (currentMode === 'interval') {
        // setInterval: 각 파티클마다 독립 타이머 (비효율적)
        lastFrameTime = performance.now()

        particles.forEach((particle, i) => {
          const timer = setInterval(() => {
            const now = performance.now()
            if (i === 0) {
              const delta = now - lastFrameTime
              updateStats(delta)
              lastFrameTime = now
            }
            particle.update(now, particles)
          }, 16)
          intervalTimers.push(timer)
        })
      } else {
        // rAF: 한 번의 콜백에서 모든 파티클 처리 (효율적)
        lastFrameTime = performance.now()

        function animateRaf(time) {
          const now = performance.now()
          const delta = now - lastFrameTime
          updateStats(delta)
          lastFrameTime = now

          particles.forEach(particle => {
            particle.update(time, particles)
          })

          rafId = requestAnimationFrame(animateRaf)
        }
        rafId = requestAnimationFrame(animateRaf)
      }
    }

    function stopAnimation() {
      isRunning = false

      intervalTimers.forEach(timer => clearInterval(timer))
      intervalTimers = []

      if (rafId) {
        cancelAnimationFrame(rafId)
        rafId = null
      }

      if (fpsRafId) {
        cancelAnimationFrame(fpsRafId)
        fpsRafId = null
      }

      document.getElementById('current-fps').textContent = '--'
    }

    function resetAnimation() {
      stopAnimation()

      frameDrops = 0
      frameTimes = []
      document.getElementById('frame-drops').textContent = '0'
      document.getElementById('avg-frame-time').textContent = '--'
      document.getElementById('max-frame-time').textContent = '--'

      createParticles()
    }

    // 초기화
    createParticles()
  </script>
</body>
</html>
